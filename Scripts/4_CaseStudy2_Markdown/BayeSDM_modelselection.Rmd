---
title: "Species distribution modelling using a generative framework, supplementary material: model selection"
author: "R. T. van den Dool, A. Morales, W. van der Werf, J.C. Douma"
date: "13/04/2022"
output: 
  html_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```

# Introduction

This document is supplementary material to the main article. It showcases model selection and generalization over multiple species with a parametric generative SDM on generated data of two (sub)species, comparing models of various complexity. It addresses the question to what extent these species have different or similar distributions, and what model complexity is warranted given the data. 


The first step is to setup the working directory and load the packages and data. 


```{r, message=FALSE, warning=FALSE, results='hide'}
if(!require("easypackages")) install.packages("easypackages")
library(easypackages)
packages("sf", "ks", "lemon", "ggplot2", "gridExtra", "grid", "cowplot", "rstudioapi", prompt = FALSE)

virtualdata = readRDS(file="Intermediate/virtualdata.Rda")
```


## Data overview
The virtualdata consists of 500,000 background points, 500 presences of (sub)species 1 and 500 presences of (sub)species 2. At each location two environmental variables from the [worldclim dataset](https://www.worldclim.org/data/worldclim21.html) were extracted: BIO1, mean annual temperature (MAT), and BIO12, mean annual precipitation (MAP). 

The species were generated by first specifying for each species the distribution of each variable at presence locations, fitting a multivariate kernel density to the distribution of the variables in the background, calculating for all background locations the probability of presence given the variables (equation 2), transforming these probabilities to a multinomial distribution (sums to 1 over all background locations), and sampling presences from this distribution. 

Marginal distributions for mean annual temperature were modelled as normal distributions (mean species 1 = 12.25, mean species 2 = 10.25, standard deviation of both species = 1.6) whereas mean annual precipitation was modelled as a lognormal distribution (meanlog=6.8, sdlog=0.3 for both species). A separate script is available to view the code used to generate the data.

```{r, echo=FALSE, fig.cap="Maps showing the suitability over Europe for each species and the generated presence points."}
map1 = ggplot()+
  ggtitle("Species 1") +
  geom_sf(data=virtualdata[virtualdata$label==0,], aes(col=spec1perc), cex=0.3, alpha=0.8, show.legend = FALSE)+ 
  scale_colour_gradient2(name="",low = "blue", mid="green", midpoint=50, high = "red")+ 
  geom_sf(data=virtualdata[virtualdata$label==1,], col="black", cex=0.5, alpha=1) 

# Species 2
map2 = ggplot()+ 
  ggtitle("Species 2") +
  geom_sf(data=virtualdata[virtualdata$label==0,], aes(col=spec2perc), cex=0.3, alpha=0.8)+ 
  scale_colour_gradient2(name="",low = "blue", mid="green", midpoint=50, high = "red")+ 
  geom_sf(data=virtualdata[virtualdata$label==2,], col="black", cex=0.5, alpha=1) 

lay <-  matrix(c(1,1,1,2,2,2,3), nrow = 1)
legend <- g_legend(map2) 
grid.arrange(map1, map2+theme(legend.position='hidden'), legend, layout_matrix = lay, top = textGrob("Suitability map and presences",gp = gpar(fontface = 2, fontsize = 15), vjust = 1.5, x = 0.5,y=0.5 
))
```


 


```{r, echo=FALSE, fig.cap = "Histograms with overlayed the distributions used for generation. The only difference in the generation of these two virtual species is in the mean distribution of temperature of presence locations, species 1 being constrained to warmer climates than species 2."}
opar = par()
par(mfrow = c(2, 2),     
    oma = c(3, 3, 1, 0), 
    mar = c(1, 1, 1.5, 1.5), 
    mgp = c(2, 1, 0)    
)

hist(virtualdata[virtualdata$label==1,]$MAT,n=14, xlim=c(5.958333, 17.36667),prob=T, main="", xlab="", cex.lab=1.2, xaxs="i")
curve(dnorm(x,mean=12.25,sd=1.6), col="red",add=T)
mtext("Species 1", side=2, line=2.5, font=1.2)
hist(virtualdata[virtualdata$label==1,]$MAP,n=18,prob=T, main="", xlim=c(372, 2460), xlab="", ylab="", xaxs="i")
curve(dlnorm(x, meanlog=6.8, sdlog=0.3),add=T, col="red")

hist(virtualdata[virtualdata$label==2,]$MAT,n=14, xlim=c(5.958333, 17.36667),prob=T, main="", xlab="", cex.lab=1.2, xaxs="i")
curve(dnorm(x,mean=10.25,sd=1.6), col="red",add=T)
mtext("Species 2", side=2, line=2.5, font=1.2)
mtext("Mean temperature", side=1, line=2.5, font=1.2)

hist(virtualdata[virtualdata$label==2,]$MAP,n=18,prob=T, main="", xlim=c(372, 2460), xlab="", ylab="", xaxs="i")
curve(dlnorm(x, meanlog=6.8, sdlog=0.3),add=T, col="red")
mtext("Mean precipitation", side=1, line=2.5, font=1.2)
par = opar
```


# Fitting generative SDMs to the data

Researchers may be interested in modelling the differences and similarities between these two species and their relation to the environmental variables that are used to predict their distribution. A generative framework could be used for this purpose. 

## The background distribution 

A generative SDM consists of distributions for the environmental variables at presence locations and at background locations (equation 2). We fit the background distribution for the two variables using a multivariate kernel density function. This function takes variable covariance into account. The background distribution will not change when different presence distributions are fit (i.e., the background is the same regardless of the species).  

```{r}
virtualdatadf = st_drop_geometry(virtualdata)
backgrounddf = virtualdatadf[virtualdatadf$label==0,]
mins = c(min(backgrounddf$MAT), min(backgrounddf$MAP))
maxs = c(max(backgrounddf$MAT), max(backgrounddf$MAP))

kde_back = ks::kde(backgrounddf[,1:2], xmin=mins,xmax=maxs) 
dkde_back = ks::dkde(fhat=kde_back,virtualdatadf[,1:2])
```

In `virtualdatadf`the *label* variable has three values: 0 for background, 1 for species 1 and 2 for species 2. *MAT* is the abbreviation for mean annual temperature, and *MAP* is the abbreviation for mean annual precipitation. `dkde` is the function that uses the multivariate kernel density object and calculates the background density for all locations (background and presences). 
```{r}
head(virtualdatadf[,c("MAT", "MAP", "label")])
```

## Fitting different presence distributions 

For the presence distributions we fit a normal distribution for mean annual temperature and a lognormal distribution for mean annual precipitation (the values of parameters may differ from the true values due to sampling variation). We then consider the following distinctions in the parameter values of these distributions between species: 

1. **All parameters are equal (assume they are the same species)**
2. **Temperature mean different (the function used for generating the data)**
3. Temperature standard deviation different
4. Temperature mean & sd different
5. Precipitation mean different
6. Precipitation standard deviation different
7. Precipitation mean & sd different
8. **All parameters are different**

Different presence distributions lead to different generative SDMs and different predictions. Models 1,2 and 8 we will show in this tutorial. Before these are fitted using maximum likelihood, we define a function (`NLLpcalc`) for the calculation of the Negative Log Likelihood at presence locations (NLLp): 

```{r}
NLLpcalc <- function(preds, label, species){ 
  prob = preds/dkde_back
  prob = prob/sum(prob)
  
  if(species == "both"){
    NLLp = -sum(log(prob[label==1 | label==2])) 
    return(NLLp)
  }
  
  NLLp = -sum(log(prob[label == species])) 
  return(NLLp)
}
```

with function argument `preds` for the predicted presence densities, `label` for the labels mentioned earlier and `species` to indicate which species is being modelled. The function `NLLpcalc` first calculates the probability of presence conditional on the environmental variables (equation 2) using the presence density and background density. These predictions are normalized to sum to unity (a multinomial distribution over all predictions/locations). Then, depending on the species under study we take the negative sum of the log probabilities at presence locations (the NLLp). The higher the predicted probabilities at presences compared to background locations, the lower the NLLp will be, indicating a better fit.  


### Model 1: All parameters are equal

In this model we assume both species have the same response to these environmental variables. After defining the likelihood function, the initial parameter values are supplied (see `pars`) and the function is numerically optimized using `optim`:

```{r, warning=FALSE}
NLLfunct1 <- function(par, data){
  mu = par[1]
  sigma = par[2]
  mulog = par[3]
  sigmalog = par[4]
  
  pres = dnorm(data[,1], mean=mu, sd=sigma) * dlnorm(x=data[,2], meanlog=mulog, sdlog=sigmalog)
  return(NLLpcalc(pres, label=data$label, species = "both"))
}

par = c(mu = 11, sigma = 2, mulog = 6.8, sigmalog = 0.3)
optimcall1 = optim(NLLfunct1, data=virtualdatadf, par=par, control=list(maxit=1000))
```



### Model 2: Temperature mean different

In model 2 we assume that the mean response to temperature is different between species by allowing the mean of the distribution to vary based on species. This is implemented by adding an additional parameter *muadjust*, and calculating the densities and NLLp for both species, adding the NLLps at the end to calculate the total NLLp. The function `optim` then attempts to find optimal parameter values that result in the lowest overall NLLp. 

The likelihoods must be calculated on the same data to allow for comparison. For comparison of the NLLp between a single model and two (or more) separate models it is required to predict with these models on and scale over all data.


```{r, warning=FALSE}
NLLfunct2 <- function(par, data){
  mu = par[1]
  sigma = par[2]
  mulog = par[3]
  sigmalog = par[4]
  muadjust = par[5]
  
  pres1 = dnorm(data[,1], mean= mu, sd=sigma) * dlnorm(x=data[,2], meanlog=mulog, sdlog=sigmalog)
  pres2 = dnorm(data[,1], mean= mu+muadjust, sd=sigma) * dlnorm(x=data[,2], meanlog=mulog, sdlog=sigmalog)
  
  nllp1 = NLLpcalc(pres1, label = data$label, species = 1)
  nllp2 = NLLpcalc(pres2, label = data$label, species = 2)
  NLLp = nllp1+nllp2
  
  return(NLLp)
}

par2 <- c(mu = 11, sigma = 2, mulog = 6.8, sigmalog = 0.3, muadjust = -2)
optimcall2 <- optim(NLLfunct2, data=virtualdatadf, par=par2, control=list(maxit=1000))  
```



### Model 8: All parameters are different

Model 8 is similarly fitted to model 2 but assumes that all parameters may be different, increasing the number of parameters from 5 to 8. This means that the mean and standard deviation of distributions for temperature and precipitation variables may vary depending on the species. 


```{r, warning=FALSE}
NLLfunct8 <- function(par, data){
  mu = par[1]
  sigma = par[2]
  mulog = par[3]
  sigmalog = par[4]
  muadjust = par[5]
  sigmaadjust = par[6]
  mulogadjust = par[7]
  sigmalogadjust = par[8]
  
  pres1 = dnorm(data[,1], mean= mu, sd=sigma) * dlnorm(x=data[,2], meanlog=mulog, sdlog=sigmalog)
  pres2 = dnorm(data[,1], mean= mu+muadjust, sd= sigma+sigmaadjust) * dlnorm(x= data[,2], meanlog= mulog+mulogadjust, sdlog= sigmalog+sigmalogadjust)
  
  nllp1 = NLLpcalc(pres1, label = data$label, species = 1)
  nllp2 = NLLpcalc(pres2, label = data$label, species = 2)
  NLLp <- nllp1+nllp2
  
  return(NLLp)
}

par8 <- c(mu = 11, sigma = 2, mulog = 6.8, sigmalog = 0.3, muadjust = -2, sigmaadjust = 0, mulogadjust = 0, sigmalogadjust = 0) 

optimcall8 <- optim(NLLfunct8, data=virtualdatadf, par=par8, control=list(maxit=2000)) 
```

# Evaluating the models 

## AIC

Models can be evaluated based on their AIC value, calculated using the NLLp and number of parameters. 
The table below gives an overview of all models and their NLLp, number of parameters and AIC. 

```{r}
getMetrics <- function(optimobj){
  NLL = optimobj$value
  npar = length(optimobj$par)
  AIC = 2 * optimobj$value + 2 * length(optimobj$par)
  return(c(NLL = NLL, npar = npar, AIC = AIC))
}

resultslist = list(optimcall1, optimcall2, optimcall8)
resultstable <- data.frame(Model=c(1:3), NLLp=rep(0,3), n.par.=rep(0,3), AIC = rep(0,3))
resultstable[,2:4] = data.frame(t(sapply(resultslist,getMetrics)))

namesvector = c("1) All parameters equal",
"2) Temperature mean different",
"8) All parameters different")

resultstable$Model = namesvector

knitr::kable(resultstable)
```

All models that varied parameters between species achieved a lower NLLp than the base model (model 1). As expected, models that allowed the mean of the temperature distribution to vary between species achieved particularly lower NLLp (models 2, 4 and 8, for models 3-7 see the appendix). The AIC shows that the addition of additional parameters is only warranted for models varying the mean of the temperature distribution. The principle of model parsimony then guides us to choosing model 2 as the preferred model, since it has the fewest parameters but still varies the mean of the temperature distribution, which is in line with how the data was generated. 

## Hypothesis testing
Additionally it is possible to test the hypothesis that there is a difference in mean distribution of the temperature variable between these two species using the likelihood ratio test: 

```{r}
teststat = 2 * (resultstable$NLLp[1] - resultstable$NLLp[2]) 
pchisq(teststat, df = 1, lower.tail = F) 
```

There is very little probability in the tail of the distribution beyond the test statistic and the test indicates the null hypothesis of *'no difference in the mu parameter of the normal distribution for temperature between the two species'* should be rejected. 

## Plotting model fits
Finally, we can plot a histogram of temperature at species 2 presences and overlay the fitted function from model 1 (red), model 2 (green) and the original generating function (black): 
```{r}
hist(virtualdatadf[virtualdatadf$label==2,]$MAT, n=15,prob=T, cex.lab=1.2,cex.axis=1.2, xlim=c(6,16), col = 'white',xlab="Mean temperature in degrees celsius", main="")
curve(dnorm(x, mean=optimcall1$par[1], sd=optimcall1$par[2]), col="red", lty=2, lwd=2, add=T)
curve(dnorm(x, mean=optimcall2$par[1]+optimcall2$par[5], sd=optimcall2$par[2]), col="green", lty=2, lwd=2, add=T)
curve(dnorm(x, mean=10.25, sd=1.6), col="black", add=T)
```

This shows the improvement in fit for this species when considering differences between species. 

# Conclusion
This exercise showed in a fictional setting with simple parametric functions how generative SDMs can be used with model selection for generalization over species or groups as well as hypothesis testing. Modelling these two virtual species as a single species (model 1) would lead to a worse performing model since there is a significant difference in the mean annual temperature distribution between species. On the other hand, modelling both species completely separately (model 8) would be overly complex as well since the distribution for mean annual rainfall is the same for both species. 

# Appendix
<details>
 <summary>Click to expand: addition of the other 5 models and the full results table shown in the article.</summary>
 
```{r, warning=FALSE, message=FALSE}
#3) Temp sd difference
NLLfunct3 <- function(par, data){
  mu <- par[1]
  sigma <- par[2]
  mulog <- par[3]
  sigmalog <- par[4]
  sigmaadjust <- par[5]
  
  pres1 <- dnorm(data[,1], mean= mu, sd=sigma) * dlnorm(x=data[,2], meanlog=mulog, sdlog=sigmalog)
  pres2 <- dnorm(data[,1], mean= mu, sd=sigma+sigmaadjust) * dlnorm(x=data[,2], meanlog=mulog, sdlog=sigmalog)
  
  nll1 = NLLpcalc(pres1, label = data$label, species = 1)
  nll2 = NLLpcalc(pres2, label = data$label, species = 2)
  NLL <- nll1+nll2
  
  return(NLL)
}

par3 <- c(mu = 11, sigma = 2, mulog = 6.8, sigmalog = 0.3, sigmaadjust = 0)
optimcall3 <- optim(NLLfunct3, data=virtualdatadf, par=par3, control=list(maxit=1000))
#4) Temp mean & sd difference
NLLfunct4 <- function(par, data){
  mu <- par[1]
  sigma <- par[2]
  mulog <- par[3]
  sigmalog <- par[4]
  muadjust <- par[5]
  sigmaadjust <- par[6]
  
  pres1 <- dnorm(data[,1], mean= mu, sd=sigma) * dlnorm(x=data[,2], meanlog=mulog, sdlog=sigmalog)
  pres2 <- dnorm(data[,1], mean= mu+muadjust, sd=sigma+sigmaadjust) * dlnorm(x=data[,2], meanlog=mulog, sdlog=sigmalog)
  
  nll1 = NLLpcalc(pres1, label = data$label, species = 1)
  nll2 = NLLpcalc(pres2, label = data$label, species = 2)
  NLL <- nll1+nll2
  
  return(NLL)
  
}

par4 <- c(mu = 11, sigma = 2, mulog = 6.8, sigmalog = 0.3, muadjust = -2, sigmaadjust = 0)
optimcall4 <- optim(NLLfunct4, data=virtualdatadf, par=par4, control=list(maxit=1000)) 
#5) Prec mean difference
NLLfunct5 <- function(par, data){
  mu <- par[1]
  sigma <- par[2]
  mulog <- par[3]
  sigmalog <- par[4]
  mulogadjust <- par[5]
  
  pres1 <- dnorm(data[,1], mean= mu, sd=sigma) * dlnorm(x=data[,2], meanlog=mulog, sdlog=sigmalog)
  pres2 <- dnorm(data[,1], mean= mu, sd=sigma) * dlnorm(x=data[,2], meanlog=mulog+mulogadjust, sdlog=sigmalog)
  
  nll1 = NLLpcalc(pres1, label = data$label, species = 1)
  nll2 = NLLpcalc(pres2, label = data$label, species = 2)
  NLL <- nll1+nll2
  
  return(NLL)
}

par5 <- c(mu = 11, sigma = 2, mulog = 6.8, sigmalog = 0.3, mulogadjust = 0)
optimcall5 <- optim(NLLfunct5, data=virtualdatadf, par=par5, control=list(maxit=1000))
#6) Prec sd difference
NLLfunct6 <- function(par, data){
  mu <- par[1]
  sigma <- par[2]
  mulog <- par[3]
  sigmalog <- par[4]
  sigmalogadjust <- par[5]
  
  pres1 <- dnorm(data[,1], mean= mu, sd=sigma) * dlnorm(x=data[,2], meanlog=mulog, sdlog=sigmalog)
  pres2 <- dnorm(data[,1], mean= mu, sd=sigma) * dlnorm(x=data[,2], meanlog=mulog, sdlog=sigmalog+sigmalogadjust)
  
  nll1 = NLLpcalc(pres1, label = data$label, species = 1)
  nll2 = NLLpcalc(pres2, label = data$label, species = 2)
  NLL = nll1+nll2
  
  return(NLL)
}

par6 <- c(mu = 11, sigma = 2, mulog = 6.8, sigmalog = 0.3, sigmalogadjust = 0)
optimcall6 <- optim(NLLfunct6, data=virtualdatadf, par=par6, control=list(maxit=1000)) 


#7) Prec mean & sd difference
NLLfunct7 <- function(par, data){
  mu <- par[1]
  sigma <- par[2]
  mulog <- par[3]
  sigmalog <- par[4]
  mulogadjust <- par[5]
  sigmalogadjust <- par[6]
  
  pres1 <- dnorm(data[,1], mean= mu, sd=sigma) * dlnorm(x=data[,2], meanlog=mulog, sdlog=sigmalog)
  pres2 <- dnorm(data[,1], mean= mu, sd=sigma) * dlnorm(x=data[,2], meanlog=mulog+mulogadjust, sdlog=sigmalog+sigmalogadjust)
  
  nll1 = NLLpcalc(pres1, label = data$label, species = 1)
  nll2 = NLLpcalc(pres2, label = data$label, species = 2)
  NLL <- nll1+nll2
  
  return(NLL)
}

par7 <- c(mu = 11, sigma = 2, mulog = 6.8, sigmalog = 0.3, mulogadjust = 0, sigmalogadjust = 0)
optimcall7 <- optim(NLLfunct7, data=virtualdatadf, par=par7, control=list(maxit=1000))

resultslist = list(optimcall1, optimcall2, optimcall3, optimcall4, optimcall5, optimcall6, optimcall7, optimcall8)
resultstable <- data.frame(Model=c(1:8), NLLp=rep(0,8), n.par.=rep(0,8), AIC = rep(0,8))
resultstable[,2:4] = data.frame(t(sapply(resultslist,getMetrics)))

namesvector = c("1) All parameters equal",
"2) Temperature mean different",
"3) Temperature sd different",
"4) Temperature mean & sd different",
"5) Precipitation mean different",
"6) Precipitation sd different",
"7) Precipitation mean & sd different",
"8) All parameters different")

resultstable$Model = namesvector

knitr::kable(resultstable)
```

</details>

